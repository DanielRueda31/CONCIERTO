<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Concierto</title>
    <script src="aframe.min.js"></script>
    <link rel="stylesheet" href="styles/pagina.css">
</head>
<body>
    
    <a-scene vr-mode-ui="enabled: true">
      <div id="controles">
        <p>Lista de controles:
          <br>Presionar p para la cámara pincipal.
          <br>Presionar Z para la cámara escenario.
          <br>Presionar X para iniciar recorrido.
          <br>Presionar C para la cámara dron.
          <br>Presionar V para iniciar recorrido.
          <br>Presionar B para la cámara de pared.
          <br>Presionar N para iniciar recorrido.
          <br>Presionar M para la cámara detrás del escenario.
        </p>
      </div>
  
      
      <!-- EXTERIORES -->

      <!-- Añadir un cielo estrellado -->
      <a-sky src="#skyTexture"></a-sky>
      <a-assets>
      <img id="skyTexture" src="imagenes/cielo2.jpg">

      </a-assets>    

          <!------------------LUGAR DONDE ESTA EL CONCIERTO------------------->
   <!-- SUELO -->
   <a-plane width="30" height="30" color="#556B2F" rotation="-90 0 0" position="0 0 0"></a-plane>

    <!------------------ESCENARIO------------------->

  <!----------SUELOS DEL ESCENARIO ------------>

      <!--  escenario suelo  Grande   -->
  <a-box width="10" height="1" depth="5" position="0 0.5 -7" material="color: black" shadow="cast: true"></a-box>
  <a-box width="3" height="1" depth="2" position="0 0.5 -3.5" material="color: black" shadow="cast: true"></a-box>
  <!-- escenario suelo pequeño   -->
  <a-box width="10" height="0.03" depth="5" position="0 1.01 -7" color="#333333" shadow="cast: true"></a-box>
  <a-box width="3" height="0.03" depth="2" position="0 1.01 -3.5" color="#333333" shadow="cast: true"></a-box>

  <!----------PARTE SUPERIOR y TRASERA DEL ESCENARIO DEL ESCENARIO   ------------>

  <a-box width="18" height="0.80" depth="6" position="0 5 -7" material="color: #D3D3D3" shadow="cast: true"></a-box>
  <a-plane width="10" height="4" material="src: imagenes/pantalla.mp4" rotation="0 0 0" position="0 2.5 -9.5" ></a-plane>
  <a-entity position="-0.5 0.7 -4.5" text="value: #MODO DIABLO; color: red; width: 8; font: mozillavr"></a-entity>
  <a-entity position="3.5 0.7 -2.5" text="value: DUKI; color: red; width: 8; font: mozillavr" ></a-entity>
  <a-entity position="6 0.7 -4.5" text="value: A.D.A TOUR; color: red; width: 8; font: mozillavr"></a-entity>

  <!-------------- COLUMNAS LATERALES DEL ESCENARIO -------------->

  <script>
    // Define las variables para el tamaño y la separación de las columnas
    const defaultHeight = 0.5;
    const rotatedHeight = 0.65; // Altura mayor para los cilindros rotados
    const columnSpacing = 0.44;
    const cylinderHeight = 0.44;
    // Bucle para generar las columnas
    for (let i = 0; i <= 10; i++) {
    // Calcula la posición en Y de la columna
    let yPos = i * columnSpacing;         
    // Determina si la rotación debe ser positiva o negativa
    let rotation = (i % 2 === 0) ? "-45" : "45";     
    // Determina la altura del cilindro
    let height = (rotation === "45" || rotation === "-45") ? rotatedHeight : defaultHeight;     
    // Genera el HTML para la columna con la posición, rotación y altura calculados
    document.write(`<a-cylinder radius="0.02" height="${cylinderHeight}" position="-5.02 ${yPos} -4.5" material="color: #C0C0C0" shadow="cast: true"></a-cylinder>`);
    document.write(`<a-cylinder radius="0.02" height="${cylinderHeight}" position="-5.52 ${yPos} -4.5" material="color: #C0C0C0" shadow="cast: true"></a-cylinder>`);
    document.write(`<a-cylinder radius="0.02" height="${height}" position="-5.28 ${yPos + 0.25} -4.5" rotation="0 0 90" material="color: #C0C0C0" shadow="cast: true"></a-cylinder>`);
    document.write(`<a-cylinder radius="0.02" height="${height}" position="-5.25 ${yPos} -4.5" rotation="0 0 ${rotation}" material="color: #C0C0C0" shadow="cast: true"></a-cylinder>`);
    }
    </script>
          
  <script>  
  // Bucle para generar las columnas
  for (let i = 0; i <= 10; i++) {
  // Calcula la posición en Y de la columna
  let yPos = i * columnSpacing;     
  // Determina si la rotación debe ser positiva o negativa
  let rotation = (i % 2 === 0) ? "-45" : "45";        
  // Determina la altura del cilindro
  let height = (rotation === "45" || rotation === "-45") ? rotatedHeight : defaultHeight;        
  // Genera el HTML para la columna con la posición, rotación y altura calculados
  document.write(`<a-cylinder radius="0.02" height="${cylinderHeight}" position="5.02 ${yPos} -4.5" material="color: #C0C0C0" shadow="cast: true"></a-cylinder>`);
  document.write(`<a-cylinder radius="0.02" height="${cylinderHeight}" position="5.52 ${yPos} -4.5" material="color: #C0C0C0" shadow="cast: true"></a-cylinder>`);
  document.write(`<a-cylinder radius="0.02" height="${height}" position="5.28 ${yPos + 0.25} -4.5" rotation="0 0 90" material="color: #C0C0C0" shadow="cast: true"></a-cylinder>`);
  document.write(`<a-cylinder radius="0.02" height="${height}" position="5.25 ${yPos} -4.5" rotation="0 0 ${rotation}" material="color: #C0C0C0" shadow="cast: true"></a-cylinder>`);
  }
  </script>

       
  <!-------------- LUCES SUPERIORES DEL ESCENARIO  ---------------------->

  <!-- Luz ambiental -->
  <a-light type="ambient" color="#FFFFFF" intensity="0.5"></a-light>
  <a-entity id="luces" ></a-entity>
  <script>
  // Función para generar un color aleatorio
  function getRandomColor() {
  var letters = '0123456789ABCDEF';
  var color = '#';
  for (var i = 0; i < 6; i++) {
  color += letters[Math.floor(Math.random() * 16)];
  }
  return color;
  }
  // Crear esferas y luces con separación de 0.5 entre ellas
  for (var i = 1; i <= 5; i++) {
  // Crear esfera
  var sphere = document.createElement('a-sphere');
  sphere.setAttribute('radius', '0.05');
  sphere.setAttribute('position', (-5.5 + i * 2) + ' 4.25 -5');
  sphere.setAttribute('color', getRandomColor());
  document.querySelector('#luces').appendChild(sphere);
  // Crear caja detrás de la esfera
  var box = document.createElement('a-box');
  box.setAttribute('width', '0.2'); // Ancho ajustado a 0.1
  box.setAttribute('height', '0.2'); // Alto ajustado a 0.1
  box.setAttribute('depth', '0.2'); // Profundidad ajustada a 0.1
  box.setAttribute('position', (-5.5 + i * 2) + ' 4.25 -5.10'); // Ajustar la posición detrás de la esfera
  box.setAttribute('color', 'black'); // Cambiar el color según sea necesario
  document.querySelector('#luces').appendChild(box);
  // Crear luz
  var light = document.createElement('a-light');
  light.setAttribute('type', 'point');
  light.setAttribute('position', (-5.5 + i * 2) + ' 4.25 -5');
  light.setAttribute('intensity', '0.6');
  light.setAttribute('color-sync', '');
  document.querySelector('#luces').appendChild(light);
  }

  // Función para cambiar el color de las esferas y las luces generadas de forma aleatoria cada cierto tiempo
  function changeColor() {
  var spheres = document.querySelectorAll('#luces a-sphere');
  var lights = document.querySelectorAll('#luces a-light');
  spheres.forEach(function(sphere) {
  var randomColor = getRandomColor(); // Generar un color aleatorio
  sphere.setAttribute('color', randomColor); // Aplicar el color aleatorio a la esfera
  });
  lights.forEach(function(light) {
  var randomColor = getRandomColor(); // Generar un color aleatorio
  light.setAttribute('color', randomColor); // Aplicar el mismo color aleatorio a la luz
  });
  }
  // Cambiar el color de las esferas y las luces generadas cada 3 segundos
  setInterval(changeColor, 900);
  </script>
  
  <!-------------- BOCINAS  ---------------------->

  <!-------bocinas izquierdas----------->
<script>
    // Define las posiciones de las bocinas izquierdas
    const leftSpeakerPositions = [
      { x: -6.1, y: 0.5 },
      { x: -7.14, y: 0.5 },
      { x: -8.16, y: 0.5 },
      { x: -6.1, y: 2.05 },
      { x: -7.14, y: 2.05 },
      { x: -8.16, y: 2.05 }
    ];
  
    // Genera las bocinas izquierdas
    leftSpeakerPositions.forEach(pos => {
    document.write(`
    <a-box width="1" height="1.5" depth="1" position="${pos.x} ${pos.y} -4.5" material="color: black" shadow="cast: true"></a-box>
    <a-circle radius="0.1" position="${pos.x - 0.01} ${pos.y - 0.2} -3.99" material="color: #808080"></a-circle>
    <a-circle radius="0.1" position="${pos.x - 0.01} ${pos.y + 0.3} -3.99" material="color: #808080"></a-circle>
    `);
    });
  </script>
  
  <!----------BOCINAS derechas------------>
  <script>
    // Define las posiciones de las bocinas derechas
    const rightSpeakerPositions = [
      { x: 6.1, y: 0.5 },
      { x: 7.14, y: 0.5 },
      { x: 8.16, y: 0.5 },
      { x: 6.1, y: 2.05 },
      { x: 7.14, y: 2.05 },
      { x: 8.16, y: 2.05 }
    ];
  
    // Genera las bocinas derechas
    rightSpeakerPositions.forEach(pos => {
    document.write(`
    <a-box width="1" height="1.5" depth="1" position="${pos.x} ${pos.y} -4.5" material="color: black" shadow="cast: true"></a-box>
    <a-circle radius="0.1" position="${pos.x + 0.01} ${pos.y - 0.2} -3.99" material="color: #808080"></a-circle>
    <a-circle radius="0.1" position="${pos.x + 0.01} ${pos.y + 0.3} -3.99" material="color: #808080"></a-circle>
    `);
    });
  </script>
  
  <a-sound id="left-speaker" src="/musica/DUKI  Malbec.mp3" position="-6.09 0.5 -3.99" autoplay="true" volume="10"></a-sound>
  <a-sound id="right-speaker" src="/musica/DUKI  Malbec.mp3" position="6.09 0.5 -3.99" autoplay="true" volume="10"></a-sound>
  
  <script>
    // Lista de canciones
    var canciones = ["musica/DUKI  Malbec.mp3", "musica/Vuelta a la Luna Remix DUKI.mp3", "musica/YSY A FT DUKI - NO DA MAS.mp3", 
    "musica/Duki  Hello Cotto.mp3", "musica/DUKI  Rockstar.mp3", "musica/DUKI  antes de perderte OG.mp3", "musica/duki NO SON KLLE (Video Oficial).mp3"];
    var indexCancion = -1; // Índice de la canción actual
  
    // Función para cambiar a la siguiente canción
    function cambiarCancion() {
      indexCancion = (indexCancion + 1) % canciones.length; // Avanza al siguiente índice circularmente
      var nuevaCancion = canciones[indexCancion]; // Obtiene la nueva canción
      document.getElementById('left-speaker').setAttribute('src', nuevaCancion); // Cambia la canción en la bocina izquierda
      document.getElementById('right-speaker').setAttribute('src', nuevaCancion); // Cambia la canción en la bocina derecha
    }
  
    // Escucha el evento 'sound-ended' para la bocina izquierda
    document.getElementById('left-speaker').addEventListener('sound-ended', cambiarCancion);
    // Escucha el evento 'sound-ended' para la bocina derecha
    document.getElementById('right-speaker').addEventListener('sound-ended', cambiarCancion);
  
    // Llama a la función cambiarCancion al cargar la página para iniciar la reproducción
    window.onload = cambiarCancion;
  
  </script>

   <!-------------- DUKI Y DUKILOVERS  ------------------------>
  
 <!-- duki -->
 <a-entity id="dukimovil" position="0 0 -0.1">
    <!-- Cabeza -->
    <a-sphere radius="0.15" position="0 2.1 -3" rotation="0 -80 0 " material="src: imagenes/cara.jpg" shadow="cast: true"></a-sphere>
    <!-- Cuerpo -->
    <a-cylinder position="0 1.75 -3" rotation="0 -170 0" radius="0.1" height="0.5" material="src: imagenes/torso.jpg"></a-cylinder>
    <!-- Brazos -->
    <a-cylinder position="-0.2 1.82 -3" rotation="0 0 130" radius="0.04" height="0.5" color="#FFDAB9"></a-cylinder>
    <a-cylinder position="0.2 1.82 -3" rotation="0 0 -130" radius="0.04" height="0.5" color="#FFDAB9"></a-cylinder>
    <!-- Piernas -->
    <a-cylinder position="-0.14 1.3 -3" rotation="0 0 160" radius="0.05" height="0.5" color="#6E7B8B"></a-cylinder>
    <a-cylinder position="0.14 1.3 -3" rotation="0 0 -160" radius="0.05" height="0.5" color="#6E7B8B"></a-cylinder>
    <a-sphere color="black" radius="0.09" position="-0.19 1.1 -2.98"></a-sphere>
    <a-sphere color="black" radius="0.09" position="0.19 1.1 -2.98"></a-sphere>
    </a-entity>
   
    <!-- Micrófono y tripoide-->
    <a-entity id="microphone" position="0 1 -2.7">
    <!-- Trípode -->
    <a-cylinder color="#CD7F32" height="1" radius="0.03"  position="0 0.5 0"></a-cylinder>
    <a-cylinder color="#CD7F32" height="0.1" radius="0.05" position="0 1 0"></a-cylinder>        
    <!-- Micrófono -->
    <a-cylinder color="#C0C0C0" height="0.2" radius="0.02" position="0 1.08 0" rotation="110 0 10"></a-cylinder>  
    <a-sphere color="black" radius="0.04" position="0 1.12 -0.10"></a-sphere>
    </a-entity>
            
    <script>
    AFRAME.registerComponent('move', {
    schema: {
      speed: { type: 'number', default: 0.001 }
    },
    init: function () {
      this.direction = 1; // Comienza moviéndose hacia la derecha
      this.maxPositionX = 1; // Límite derecho
      this.minPositionX = -1; // Límite izquierdo
    },
    tick: function (time, timeDelta) {
    const el = this.el;
    const position = el.getAttribute('position');  
    // Calcular nueva posición
    let newPositionX = position.x + this.direction * this.data.speed * timeDelta;
    // Verificar si la nueva posición está dentro de los límites
    if (newPositionX > this.maxPositionX) {
        newPositionX = this.maxPositionX;
        this.direction = -1; // Cambiar dirección hacia la izquierda
      } else if (newPositionX < this.minPositionX) {
        newPositionX = this.minPositionX;
        this.direction = 1; // Cambiar dirección hacia la derecha
      }
    // Actualizar posición
    el.setAttribute('position', { x: newPositionX, y: position.y, z: position.z });
    }
    });
    
    document.querySelector('#dukimovil').setAttribute('move', {speed: 0.0005});
    document.querySelector('#microphone').setAttribute('move', {speed: 0.0005});
    </script>
<!--------- DUKI LOVERS---------->
<a-entity id="contenedor" position="0 -1.1 8">
  <script>
    var filas = 8;
    var columnas = 8;
    var espaciado = 1.5;
    var margen = 0.5; // Margen de seguridad para evitar colisiones
    var personaOriginal = document.createElement('a-entity');
    personaOriginal.innerHTML = `
      <a-sphere radius="0.15" position="0 2.1 -3" rotation="0 75 0" material="src: imagenes/cara2.jpg" shadow="cast: true"></a-sphere>
      <a-cylinder position="0 1.75 -3" rotation="0 -20 0" radius="0.1" height="0.5" material="src: imagenes/torsofan.jpg"></a-cylinder>
      <a-cylinder class="brazo-izquierdo" position="-0.2 1.82 -3" rotation="0 0 130" radius="0.04" height="0.5" color="#FFDAB9"></a-cylinder>
      <a-cylinder class="brazo-derecho" position="0.2 1.82 -3" rotation="0 0 -130" radius="0.04" height="0.5" color="#FFDAB9"></a-cylinder>
      <a-entity class="pierna-izquierda" position="-0.14 1.35 -3" rotation="0 0 160">
            <a-cylinder rotation="0 0 0" radius="0.05" height="0.5" color="#A52A2A"></a-cylinder>
            <a-sphere color="black" radius="0.09" position="0.01 0.25 0"></a-sphere>
        </a-entity>
        <a-entity class="pierna-derecha" position="0.14 1.35 -3" rotation="0 0 -160">
            <a-cylinder rotation="0 0 0" radius="0.05" height="0.5" color="#A52A2A"></a-cylinder>
            <a-sphere color="black" radius="0.09" position="-0.01 0.25 0"></a-sphere>
        </a-entity>
    `;

    for (var i = 0; i < filas; i++) {
      for (var j = 0; j < columnas; j++) {
          var persona = personaOriginal.cloneNode(true);
          var posX = (i * espaciado - (filas / 2 * espaciado)) + Math.random() * espaciado - margen; // Agregar un valor aleatorio dentro del espaciado y restar el margen
          var posZ = (j * espaciado - (columnas / 2 * espaciado)) + Math.random() * espaciado - margen; // Agregar un valor aleatorio dentro del espaciado y restar el margen
          persona.setAttribute('position', posX + ' 0 ' + posZ);

          document.getElementById('contenedor').appendChild(persona);
          iniciarAnimaciones(persona, posX, posZ);
      }
    }
 
  function iniciarAnimaciones(entidad, posX, posZ) {
      setTimeout(() => {
          entidad.setAttribute('animation', {
              property: 'position',
              to: posX + ' 0.5 ' + posZ,
              loop: true,
              dir: 'alternate',
              easing: 'easeInOutQuad',
              dur: 1000
          });
      }, Math.random() * 2000);

      setTimeout(() => {
          var brazoIzquierdo = entidad.querySelector('.brazo-izquierdo');
          var brazoDerecho = entidad.querySelector('.brazo-derecho');
          brazoIzquierdo.setAttribute('animation__brazo', {
              property: 'rotation',
              from: '0 0 120',
              to: '0 0 80',
              loop: true,
              dir: 'alternate',
              easing: 'easeInOutQuad',
              dur: 600
          });
          brazoDerecho.setAttribute('animation__brazo', {
              property: 'rotation',
              from: '0 0 -120',
              to: '0 0 -80',
              loop: true,
              dir: 'alternate',
              easing: 'easeInOutQuad',
              dur: 600
          });
      }, Math.random() * 2000);

      setTimeout(() => {
        var piernaIzquierda = entidad.querySelector('.pierna-izquierda');
            var piernaDerecha = entidad.querySelector('.pierna-derecha');
            piernaIzquierda.setAttribute('animation', {
                property: 'rotation',
                from: '0 0 160',
                to: '0 0 130',
                loop: true,
                dir: 'alternate',
                easing: 'easeInOutQuad',
                dur: 800
            });
            piernaDerecha.setAttribute('animation', {
                property: 'rotation',
                from: '0 0 -160',
                to: '0 0 -130',
                loop: true,
                dir: 'alternate',
                easing: 'easeInOutQuad',
                dur: 800
            });
        }, Math.random() * 2000);
    }
    </script>
</a-entity>
  
      <!----------------------CAMARAS Y DRONES ------------------>

   
    <!-- Cámara principal -->
    <a-entity id="mainCamera" camera="active: true" wasd-controls look-controls position="0 2 0" ></a-entity>
  <!-- Contenedor para el dron -->
  <a-entity id="dronContainer" position="0 7 4" rotation="-20 0 0">
    <!-- DRON CON CAMARA -->
    <a-entity id="dron">
      <a-entity gltf-model="url(modelos/dron5.glb)" scale="1 1 1" position="0 8 4" ></a-entity>
       
        <!-- Añade la nueva cámara -->
        <a-entity id="cameraDrone" camera="active: false" position="0 7.2 4"  rotation="-60 0 0" ></a-entity>
    </a-entity>
</a-entity>


    <!------------ Cámaras fijas ----------->
    <a-entity id="contedorfijaA" position="0 1 0" rotation="0 0 0">
      <a-entity id="fija1">
        <a-entity gltf-model="url(modelos/CAMARASINBASE.glb)" scale="10 10 10" position="4.5 0.5 -4.8" rotation="0 -60 0"></a-entity>
      <!-- Trípode -->
      <a-cylinder color="#CCCCCC" height="0.5" radius="0.03"  position="4.5 0.25 -4.8"></a-cylinder>
        <!-- Añade la nueva cámara -->
      <a-entity id="camerafijaA" camera="active: false" position="4.3 0.5 -4.7"   rotation="0 130 0"></a-entity>
      </a-entity>
      </a-entity>
      
      <a-entity id="contedorCamaraPared" position="0 1 0" rotation="0 0 0">
        <a-entity id="fija2">
          <a-entity gltf-model="url(modelos/CAMARASINBASE.glb)" scale="10 10 10" position="-14 1 5" rotation="0 90 0"></a-entity>
          <a-entity id="camerafijaB" camera="active: false" camera="userHeight: 1.6" position="-13.6 1 5" rotation="0 -90 0"></a-entity>
        </a-entity>
      </a-entity>

      <a-entity id="contedorCamaraPared" position="0 0 0" rotation="0 0 0">
        <a-entity id="fija3">
          <a-entity gltf-model="url(modelos/CAMARACONBASE.glb)" scale="0.005 0.005 0.005" position="-4.5 1 -9" rotation="0 135 0"></a-entity>
          <a-entity id="camerafijaC" camera="active: false" camera="userHeight: 1.6" position="-4.5 2 -8.5" rotation="0 -120 0"></a-entity>
        </a-entity>
      </a-entity>
      <a-entity id="touchControls" touch-controls controller-cursor="fuse: true; fuzzyfar: true"></a-entity>


      <script>
        // Obtener referencia a la cámara principal, la del dron y las cámaras fijas
        var mainCamera = document.getElementById('mainCamera');
        var cameraDrone = document.getElementById('cameraDrone');
        var cameraFija = document.getElementById('camerafijaA');
        var cameraFijab = document.getElementById('camerafijaB');
        var cameraFijac = document.getElementById('camerafijaC'); // Nueva cámara fija C
        var dronContainer = document.getElementById('dronContainer');
       
        // Función para cambiar a la cámara del dron
        function activateDroneCamera() {
            mainCamera.setAttribute('camera', 'active', false);
            cameraDrone.setAttribute('camera', 'active', true);
            cameraFija.setAttribute('camera', 'active', false); // Desactivar cámaras fijas
            cameraFijab.setAttribute('camera', 'active', false);
            cameraFijac.setAttribute('camera', 'active', false);
        }
       
        // Función para cambiar a la cámara principal
        function activateMainCamera() {
            mainCamera.setAttribute('camera', 'active', true);
            cameraDrone.setAttribute('camera', 'active', false);
            cameraFija.setAttribute('camera', 'active', false); // Desactivar cámaras fijas
            cameraFijab.setAttribute('camera', 'active', false);
            cameraFijac.setAttribute('camera', 'active', false);
        }
       
        // Función para cambiar a la cámara fija A
        function activateFixedCamera() {
            mainCamera.setAttribute('camera', 'active', false);
            cameraDrone.setAttribute('camera', 'active', false);
            cameraFija.setAttribute('camera', 'active', true); // Activar cámara fija A
            cameraFijab.setAttribute('camera', 'active', false);
            cameraFijac.setAttribute('camera', 'active', false);
        }
       
        // Función para cambiar a la cámara fija B
        function activateFixedCamerab() {
            mainCamera.setAttribute('camera', 'active', false);
            cameraDrone.setAttribute('camera', 'active', false);
            cameraFija.setAttribute('camera', 'active', false);
            cameraFijab.setAttribute('camera', 'active', true); // Activar cámara fija B
            cameraFijac.setAttribute('camera', 'active', false);
        }
       
        // Función para cambiar a la cámara fija C
        function activateFixedCamerac() {
            mainCamera.setAttribute('camera', 'active', false);
            cameraDrone.setAttribute('camera', 'active', false);
            cameraFija.setAttribute('camera', 'active', false);
            cameraFijab.setAttribute('camera', 'active', false);
            cameraFijac.setAttribute('camera', 'active', true); // Activar cámara fija C
        }
       
        // Agregar un listener de evento para detectar cuando se presiona la tecla correspondiente a cada cámara
        document.addEventListener('keydown', function(event) {
            if (event.key === 'c') {
                activateDroneCamera();
            } else if (event.key === 'p') {
                activateMainCamera();
            } else if (event.key === 'z') {
                activateFixedCamera();
            } else if (event.key === 'b') {
                activateFixedCamerab();
            } else if (event.key === 'm') { // Detectar tecla "m" para la cámara fija C
                activateFixedCamerac();
            }
        });

      // Agregar listeners de eventos táctiles para cambiar cámaras
      document.querySelector('#touchControls').addEventListener('touchstart', function() {
        activateDroneCamera();
      });

      document.querySelector('#touchControls').addEventListener('touchstart', function(e) {
        e.preventDefault(); // Prevenir el comportamiento predeterminado del navegador
        activateMainCamera();
      }, { once: true })
      
        AFRAME.registerComponent('move-drone', {
    schema: {
      speed: { type: 'number', default: 0.001 },
      maxPositionX: { type: 'number', default: 5 },
      minPositionX: { type: 'number', default: -5 },
      maxPositionZ: { type: 'number', default: 9 },
      minPositionZ: { type: 'number', default: 4 },
      rotationStart: { type: 'number', default: -20 },
      rotationEnd: { type: 'number', default: -60 }
    },

    init: function () {
      this.direction = 1;
      this.rotationDirection = 1;
      this.angle = 0; // Ángulo inicial
      this.moving = false; // Bandera para rastrear si el dron está en movimiento
    },

    tick: function (time, timeDelta) {
      if (!this.moving) return; // Salir si el dron no está en movimiento

      const el = this.el;
      const rotation = el.getAttribute('rotation');
      const data = this.data;

      // Calcular nuevo ángulo
      this.angle += this.direction * data.speed * timeDelta;

      // Calcular nueva posición X
      let newPositionX = data.maxPositionX * Math.cos(this.angle);

      // Verificar si la nueva posición X está dentro de los límites
      if (newPositionX > data.maxPositionX) {
        newPositionX = data.maxPositionX;
        this.direction = -1; // Cambiar dirección
      } else if (newPositionX < data.minPositionX) {
        newPositionX = data.minPositionX;
        this.direction = 1; // Cambiar dirección
      }

      // Calcular nueva posición Z
      let newPositionZ = data.minPositionZ + (data.maxPositionZ - data.minPositionZ) * Math.sin(this.angle);

      // Calcular nueva rotación
      let newRotationX = rotation.x;
      if (newPositionZ === data.maxPositionZ) {
        newRotationX = data.rotationEnd;
        this.rotationDirection = -1;
      } else if (newPositionZ === data.minPositionZ) {
        newRotationX = data.rotationStart;
        this.rotationDirection = 1;
      } else {
        newRotationX += this.rotationDirection * 0.01;
      }

      // Actualizar posición y rotación
      el.setAttribute('position', {
        x: newPositionX,
        y: rotation.y,
        z: newPositionZ
      });
      el.setAttribute('rotation', {
        x: newRotationX,
        y: rotation.y,
        z: rotation.z
      });
    },

    toggleMovement: function () {
      // Cambia el estado de movimiento del dron
      this.moving = !this.moving;
    }
  });

  // Función para iniciar o detener el movimiento del dron cuando se presiona la tecla "v"
  function handleDroneMovementKeyPress(event) {
    // Verifica si la tecla presionada es "v"
    if (event.key === 'v') {
      // Aplica el componente personalizado al contenedor del dron
      const dronContainer = document.getElementById('dronContainer');
      // Llama a la función toggleMovement del componente move-drone
      dronContainer.setAttribute('move-drone', '');
      dronContainer.components['move-drone'].toggleMovement();
    }
  }

  // Agrega un event listener al documento para escuchar los eventos de teclado
  document.addEventListener('keydown', handleDroneMovementKeyPress);
</script>
<script>
  AFRAME.registerComponent('rotate-container', {
    init: function () {
      // Inicializa el componente pero no inicia la rotación automáticamente
      this.animating = false; // Agrega una bandera para rastrear el estado de la animación
    },
    rotateForward: function () {
      const el = this.el;
      const initialRotation = el.getAttribute('rotation');
      const finalRotation = { x: 0, y: 85, z: 0 };
      el.setAttribute('animation', {
        property: 'rotation',
        dur: 6000, // Duración de la animación en milisegundos
        easing: 'linear', // Tipo de interpolación
        from: `${initialRotation.x} ${initialRotation.y} ${initialRotation.z}`,
        to: `${finalRotation.x} ${finalRotation.y} ${finalRotation.z}`
      });
      el.addEventListener('animationcomplete', () => {
        this.rotateBackward();
      });
      this.animating = true; // Establece la bandera de animación en true cuando la animación está en progreso
    },
    rotateBackward: function () {
      const el = this.el;
      const initialRotation = { x: 0, y: 85, z: 0 };
      const finalRotation = { x: 0, y: 0, z: 0 };
      el.setAttribute('animation', {
        property: 'rotation',
        dur: 6000, // Duración de la animación en milisegundos
        easing: 'linear', // Tipo de interpolación
        from: `${initialRotation.x} ${initialRotation.y} ${initialRotation.z}`,
        to: `${finalRotation.x} ${finalRotation.y} ${finalRotation.z}`
      });
      el.addEventListener('animationcomplete', () => {
        this.rotateForward();
      });
      this.animating = true; // Establece la bandera de animación en true cuando la animación está en progreso
    },
    toggleRotation: function () {
      // Si la animación está en curso, detén la animación; de lo contrario, inicia la animación
      if (this.animating) {
        this.stopRotation();
      } else {
        this.rotateForward();
      }
    },
    stopRotation: function () {
      const el = this.el;
      el.removeAttribute('animation'); // Detiene la animación eliminando el atributo 'animation'
      this.animating = false; // Establece la bandera de animación en false cuando la animación se detiene
    }
  });

  // Función para iniciar o detener la rotación cuando se presiona la tecla "z"
  function handleRotationKeyPress(event) {
    // Aplica el componente personalizado al contenedor fijo A
    const contenedorFijoA = document.getElementById('contedorfijaA');
    contenedorFijoA.setAttribute('rotate-container', '');
    // Llama a la función toggleRotation del componente rotate-container
    contenedorFijoA.components['rotate-container'].toggleRotation();
  }

  // Agrega un event listener al documento para escuchar los eventos de teclado
  document.addEventListener('keydown', function(event) {
    // Verifica si la tecla presionada es "z"
    if (event.key === 'x') {
      handleRotationKeyPress(event);
    }
  });
</script>
<script>
  AFRAME.registerComponent('slide-animation', {
    init: function () {
      this.direction = 1; // Dirección inicial del deslizamiento
      this.distance = 5; // Distancia total de deslizamiento
      this.speed = 0.005; // Velocidad de deslizamiento (más lenta que antes)
      this.currentDistance = 0; // Distancia actual recorrida
      this.isSliding = false; // Bandera para rastrear si la animación está en curso
    },

    tick: function (time, timeDelta) {
      if (!this.isSliding) return; // Salir si la animación no está en curso

      const el = this.el;
      const position = el.getAttribute('position');

      // Actualizar la posición en el eje Z según la dirección y la velocidad
      position.z += this.direction * this.speed * timeDelta;

      // Verificar si se alcanzó la distancia máxima o mínima
      if (Math.abs(position.z) >= this.distance) {
        // Ajustar la posición para que no se salga de los límites
        position.z = this.direction === 1 ? this.distance : -this.distance;
        // Cambiar la dirección
        this.direction *= -1;
      }

      // Actualizar la posición del elemento
      el.setAttribute('position', position);
    },

    toggleSlide: function () {
      // Cambiar el estado de la animación
      this.isSliding = !this.isSliding;
    }
  });

  // Función para iniciar o detener el deslizamiento del contenedor cuando se presiona la tecla "n"
  function handleContainerSlideKeyPress(event) {
    // Verifica si la tecla presionada es "n"
    if (event.key === 'n') {
      // Aplica el componente personalizado al contenedor de la cámara
      const contenedorCamaraPared = document.getElementById('contedorCamaraPared');
      // Llama a la función toggleSlide del componente slide-animation
      contenedorCamaraPared.setAttribute('slide-animation', '');
      contenedorCamaraPared.components['slide-animation'].toggleSlide();
    }
  }

  // Agrega un event listener al documento para escuchar los eventos de teclado
  document.addEventListener('keydown', handleContainerSlideKeyPress);
</script>

<a-entity gltf-model="url(modelos/gradas.glb)" scale="0.030 0.030 0.030" position="13.1 0 2" rotation="0 -90 0"></a-entity>
<a-entity gltf-model="url(modelos/gradas.glb)" scale="0.030 0.030 0.030" position="13.1 0 8" rotation="0 -90 0"></a-entity>
<a-entity gltf-model="url(modelos/gradas.glb)" scale="0.030 0.030 0.030" position="-13.1 0 8" rotation="0 90 0"></a-entity>
<a-entity gltf-model="url(modelos/gradas.glb)" scale="0.030 0.030 0.030" position="-13.1 0 2" rotation="0 90 0"></a-entity>
<a-entity gltf-model="url(modelos/dj.glb)" scale="0.5 0.5 0.5" position="-1.5 0.5 -5.3" rotation="0 180 0"></a-entity>


<a-entity class="orbit" position="0 3 0" rotation="0 0 0"
            animation="property: rotation; to: 0 360 360; loop: true; dur: 40000;  easing: linear">
        </a-entity>

        <a-entity class="orbit" position="0 0 0" rotation="0 0 -45"
            animation="property: rotation; to: 0 -360 0; loop: true; dur: 30000; easing: linear">
        </a-entity>

        <a-entity class="orbit" position="0 -3 0" rotation="0 0 -90"
            animation="property: rotation; to: 0 360 360; loop: true; dur: 20000; easing: linear">
        </a-entity>

        <a-entity class="orbit" position="0 0 0" rotation="0 0 -120"
            animation="property: rotation; to: 360 -360 0; loop: true; dur: 50000; easing: linear">
        </a-entity>



  <script>
    window.addEventListener('load', initScene)

const meteors = [
    { x: 0, y: 0, z: -30 },
    { x: 0, y: 0, z: 30 },
    { x: 30, y: 0, z: 0 },
    { x: -30, y: 0, z: 0 },
    { x: 20, y: 0, z: 20 },
    { x: 20, y: 0, z: -20 },
    { x: -20, y: 0, z: -20 },
    { x: -20, y: 0, z: 20 }
]

let meteor, score = 0

function initScene() {

    let orbits = document.querySelectorAll('.orbit')

    orbits.forEach(orbit => {

        meteors.forEach(pos => {

            meteor = document.createElement('a-entity')
            meteor.setAttribute('geometry', { primitive: 'sphere', radius: Math.random() * 3 + 0.5 })
            meteor.setAttribute('material', { shader: 'flat', src: 'imagenes/mundo2.jpg' })
            meteor.setAttribute('class', 'meteor')
            meteor.object3D.position.set(pos.x, pos.y, pos.z)


            orbit.appendChild(meteor)
        })
    })
}
  
  </script>      
      </a-scene>
  </body>
  </html>
  